CCS PCM C Compiler, Version 5.112, 5967               20-janv.-26 10:31

               Filename:   C:\Users\RACHID\Desktop\Proteus\PIC Projets\PWM signal PIC16F877A\PWM signal PIC16F877A.X\dist\default\debug\PWM_signal_PIC16F877A.X.debug.lst

               ROM used:   500 words (6%)
                           Largest free fragment is 2048
               RAM used:   10 (3%) at main() level
                           37 (10%) worst case
               Stack used: 2 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1B2
0003:  NOP
.................... #import(file="build/default/debug/main.o")
.................... #include <16F877A.h>
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
0004:  BTFSC  03.1
0005:  GOTO   009
0006:  MOVLW  3B
0007:  MOVWF  04
0008:  BCF    03.7
0009:  CLRF   77
000A:  CLRF   78
000B:  CLRF   79
000C:  CLRF   7A
000D:  CLRF   3B
000E:  CLRF   3C
000F:  CLRF   3D
0010:  CLRF   3E
0011:  MOVF   3A,W
0012:  IORWF  39,W
0013:  IORWF  38,W
0014:  IORWF  37,W
0015:  BTFSC  03.2
0016:  GOTO   047
0017:  MOVLW  20
0018:  MOVWF  3F
0019:  BCF    03.0
001A:  RLF    33,F
001B:  RLF    34,F
001C:  RLF    35,F
001D:  RLF    36,F
001E:  RLF    3B,F
001F:  RLF    3C,F
0020:  RLF    3D,F
0021:  RLF    3E,F
0022:  MOVF   3A,W
0023:  SUBWF  3E,W
0024:  BTFSS  03.2
0025:  GOTO   030
0026:  MOVF   39,W
0027:  SUBWF  3D,W
0028:  BTFSS  03.2
0029:  GOTO   030
002A:  MOVF   38,W
002B:  SUBWF  3C,W
002C:  BTFSS  03.2
002D:  GOTO   030
002E:  MOVF   37,W
002F:  SUBWF  3B,W
0030:  BTFSS  03.0
0031:  GOTO   041
0032:  MOVF   37,W
0033:  SUBWF  3B,F
0034:  MOVF   38,W
0035:  BTFSS  03.0
0036:  INCFSZ 38,W
0037:  SUBWF  3C,F
0038:  MOVF   39,W
0039:  BTFSS  03.0
003A:  INCFSZ 39,W
003B:  SUBWF  3D,F
003C:  MOVF   3A,W
003D:  BTFSS  03.0
003E:  INCFSZ 3A,W
003F:  SUBWF  3E,F
0040:  BSF    03.0
0041:  RLF    77,F
0042:  RLF    78,F
0043:  RLF    79,F
0044:  RLF    7A,F
0045:  DECFSZ 3F,F
0046:  GOTO   019
0047:  MOVF   3B,W
0048:  MOVWF  00
0049:  INCF   04,F
004A:  MOVF   3C,W
004B:  MOVWF  00
004C:  INCF   04,F
004D:  MOVF   3D,W
004E:  MOVWF  00
004F:  INCF   04,F
0050:  MOVF   3E,W
0051:  MOVWF  00
0052:  RETURN
*
0084:  MOVLW  10
0085:  MOVWF  37
0086:  CLRF   77
0087:  CLRF   7A
0088:  RRF    34,F
0089:  RRF    33,F
008A:  BTFSS  03.0
008B:  GOTO   092
008C:  MOVF   35,W
008D:  ADDWF  77,F
008E:  BTFSC  03.0
008F:  INCF   7A,F
0090:  MOVF   36,W
0091:  ADDWF  7A,F
0092:  RRF    7A,F
0093:  RRF    77,F
0094:  RRF    79,F
0095:  RRF    78,F
0096:  DECFSZ 37,F
0097:  GOTO   088
*
012A:  MOVLW  20
012B:  MOVWF  37
012C:  CLRF   33
012D:  CLRF   34
012E:  CLRF   35
012F:  CLRF   36
0130:  MOVF   2E,W
0131:  MOVWF  7A
0132:  MOVF   2D,W
0133:  MOVWF  79
0134:  MOVF   2C,W
0135:  MOVWF  78
0136:  MOVF   2B,W
0137:  MOVWF  77
0138:  BCF    03.0
0139:  BTFSS  77.0
013A:  GOTO   149
013B:  MOVF   2F,W
013C:  ADDWF  33,F
013D:  MOVF   30,W
013E:  BTFSC  03.0
013F:  INCFSZ 30,W
0140:  ADDWF  34,F
0141:  MOVF   31,W
0142:  BTFSC  03.0
0143:  INCFSZ 31,W
0144:  ADDWF  35,F
0145:  MOVF   32,W
0146:  BTFSC  03.0
0147:  INCFSZ 32,W
0148:  ADDWF  36,F
0149:  RRF    36,F
014A:  RRF    35,F
014B:  RRF    34,F
014C:  RRF    33,F
014D:  RRF    7A,F
014E:  RRF    79,F
014F:  RRF    78,F
0150:  RRF    77,F
0151:  DECFSZ 37,F
0152:  GOTO   138
.................... 
.................... #list
.................... 
.................... #device ADC=16
.................... #fuses HS, NOWDT, NOPUT, NOPROTECT, NOLVP
.................... #use delay(clock=16000000)
*
019D:  MOVLW  25
019E:  MOVWF  04
019F:  BCF    03.7
01A0:  MOVF   00,W
01A1:  BTFSC  03.2
01A2:  GOTO   1B1
01A3:  MOVLW  05
01A4:  MOVWF  78
01A5:  CLRF   77
01A6:  DECFSZ 77,F
01A7:  GOTO   1A6
01A8:  DECFSZ 78,F
01A9:  GOTO   1A5
01AA:  MOVLW  2E
01AB:  MOVWF  77
01AC:  DECFSZ 77,F
01AD:  GOTO   1AC
01AE:  GOTO   1AF
01AF:  DECFSZ 00,F
01B0:  GOTO   1A3
01B1:  RETURN
.................... 
.................... /* 
....................  * Gestion PWM selon datasheet PIC16F877A
....................  * CCP1 (RC2) en mode PWM
....................  */
.................... 
.................... /*************** Définitions des registres ***************/
.................... #byte PR2 = 0x92
.................... #byte T2CON = 0x12
.................... #byte CCPR1L = 0x15
.................... #byte CCP1CON = 0x17
.................... #byte TRISC = 0x87
.................... #byte TMR2 = 0x11
.................... #byte PIR1 = 0x0C
.................... 
.................... /*************** Prototypes ***************/
.................... void pwm_init(unsigned int16 pwm_frequency, unsigned int8 prescaler);
.................... void pwm_set_duty_(unsigned int16 duty_value);
.................... void pwm_set_duty_percent(unsigned int8 percent);
.................... unsigned int16 calculate_pr2(unsigned int16 frequency, unsigned int8 prescaler);
.................... 
.................... /*************** Variables globales ***************/
.................... unsigned int16 max_duty_value = 0;
.................... 
.................... /*************** Fonction principale ***************/
.................... void main(void) {
01B2:  MOVF   03,W
01B3:  ANDLW  1F
01B4:  MOVWF  03
01B5:  CLRF   21
01B6:  CLRF   20
01B7:  MOVLW  FF
01B8:  MOVWF  22
01B9:  BCF    03.7
01BA:  BSF    03.5
01BB:  BSF    1F.0
01BC:  BSF    1F.1
01BD:  BSF    1F.2
01BE:  BCF    1F.3
01BF:  MOVLW  07
01C0:  MOVWF  1C
01C1:  BCF    03.7
....................     unsigned int8 percent;
....................     
....................     // Initialisation PWM à 1kHz avec prescaler = 4
....................     pwm_init(1000, 4);
01C2:  MOVLW  03
01C3:  BCF    03.5
01C4:  MOVWF  25
01C5:  MOVLW  E8
01C6:  MOVWF  24
01C7:  MOVLW  04
01C8:  MOVWF  26
01C9:  GOTO   053
....................     
....................     while(1) {
....................         // Fade in (0% à 100%)
....................         for(percent = 0; percent <= 100; percent++) {
01CA:  CLRF   23
01CB:  MOVF   23,W
01CC:  SUBLW  64
01CD:  BTFSS  03.0
01CE:  GOTO   1D7
....................             pwm_set_duty_percent(percent);
01CF:  MOVF   23,W
01D0:  MOVWF  24
01D1:  CALL   111
....................             delay_ms(20);
01D2:  MOVLW  14
01D3:  MOVWF  25
01D4:  CALL   19D
01D5:  INCF   23,F
01D6:  GOTO   1CB
....................         }
....................         
....................         delay_ms(500);
01D7:  MOVLW  02
01D8:  MOVWF  24
01D9:  MOVLW  FA
01DA:  MOVWF  25
01DB:  CALL   19D
01DC:  DECFSZ 24,F
01DD:  GOTO   1D9
....................         
....................         // Fade out (100% à 0%)
....................         for(percent = 100; percent > 0; percent--) {
01DE:  MOVLW  64
01DF:  MOVWF  23
01E0:  MOVF   23,F
01E1:  BTFSC  03.2
01E2:  GOTO   1EB
....................             pwm_set_duty_percent(percent);
01E3:  MOVF   23,W
01E4:  MOVWF  24
01E5:  CALL   111
....................             delay_ms(20);
01E6:  MOVLW  14
01E7:  MOVWF  25
01E8:  CALL   19D
01E9:  DECF   23,F
01EA:  GOTO   1E0
....................         }
....................         
....................         delay_ms(500);
01EB:  MOVLW  02
01EC:  MOVWF  24
01ED:  MOVLW  FA
01EE:  MOVWF  25
01EF:  CALL   19D
01F0:  DECFSZ 24,F
01F1:  GOTO   1ED
01F2:  GOTO   1CA
....................     }
.................... }
.................... 
01F3:  SLEEP
.................... /*************** Fonctions PWM ***************/
.................... 
.................... /*
....................  * Initialise le module PWM
....................  */
.................... void pwm_init(unsigned int16 pwm_frequency, unsigned int8 prescaler) {
....................     unsigned int8 t2con_value;
....................     unsigned int16 pr2_value;
....................     
....................     // 1. Configurer le prescaler
....................     switch(prescaler) {
*
0053:  MOVF   26,W
0054:  XORLW  01
0055:  BTFSC  03.2
0056:  GOTO   05E
0057:  XORLW  05
0058:  BTFSC  03.2
0059:  GOTO   061
005A:  XORLW  14
005B:  BTFSC  03.2
005C:  GOTO   064
005D:  GOTO   067
....................         case 1:
....................             t2con_value = 0b00000100;  // T2CKPS = 00
005E:  MOVLW  04
005F:  MOVWF  27
....................             break;
0060:  GOTO   06B
....................         case 4:
....................             t2con_value = 0b00000101;  // T2CKPS = 01
0061:  MOVLW  05
0062:  MOVWF  27
....................             break;
0063:  GOTO   06B
....................         case 16:
....................             t2con_value = 0b00000111;  // T2CKPS = 1x
0064:  MOVLW  07
0065:  MOVWF  27
....................             break;
0066:  GOTO   06B
....................         default:
....................             t2con_value = 0b00000101;  // Par défaut prescaler = 4
0067:  MOVLW  05
0068:  MOVWF  27
....................             prescaler = 4;
0069:  MOVLW  04
006A:  MOVWF  26
....................     }
....................     
....................     // 2. Calculer PR2
....................     pr2_value = calculate_pr2(pwm_frequency, prescaler);
006B:  MOVF   25,W
006C:  MOVWF  2B
006D:  MOVF   24,W
006E:  MOVWF  2A
006F:  MOVF   26,W
0070:  MOVWF  2C
*
00E5:  MOVF   79,W
00E6:  MOVWF  29
00E7:  MOVF   78,W
00E8:  MOVWF  28
....................     
....................     // 3. Désactiver le Timer2 pendant la configuration
....................     T2CON = 0;
00E9:  CLRF   12
....................     
....................     // 4. Configurer la broche RC2/CCP1 comme sortie
....................     output_bit(PIN_C2, 0);
00EA:  BCF    07.2
00EB:  BCF    22.2
00EC:  MOVF   22,W
00ED:  BSF    03.5
00EE:  MOVWF  07
....................     TRISC = 0b11111011;
00EF:  MOVLW  FB
00F0:  MOVWF  07
....................     
....................     // 5. Écrire la valeur de PR2
....................     PR2 = (unsigned int8)pr2_value;
00F1:  BCF    03.5
00F2:  MOVF   28,W
00F3:  BSF    03.5
00F4:  MOVWF  12
....................     
....................     // 6. Initialiser les registres PWM à 0%
....................     CCPR1L = 0;
00F5:  BCF    03.5
00F6:  CLRF   15
....................     CCP1CON = 0b00001100;  // Mode PWM, bits DC1B = 00
00F7:  MOVLW  0C
00F8:  MOVWF  17
....................     
....................     // 7. Calculer la valeur maximale du duty cycle
....................     max_duty_value = (pr2_value + 1) * 4;
00F9:  MOVLW  01
00FA:  ADDWF  28,W
00FB:  MOVWF  2A
00FC:  MOVF   29,W
00FD:  MOVWF  2B
00FE:  BTFSC  03.0
00FF:  INCF   2B,F
0100:  RLF    2A,W
0101:  MOVWF  20
0102:  RLF    2B,W
0103:  MOVWF  21
0104:  RLF    20,F
0105:  RLF    21,F
0106:  MOVLW  FC
0107:  ANDWF  20,F
....................     
....................     // 8. Activer le Timer2 avec le prescaler choisi
....................     T2CON = t2con_value | 0b00000100;  // TMR2ON = 1
0108:  MOVF   27,W
0109:  IORLW  04
010A:  MOVWF  12
....................     
....................     // 9. Attendre que le Timer2 déborde
....................     while(!(PIR1 & 0x02));  // Attendre TMR2IF = 1
010B:  BTFSS  0C.1
010C:  GOTO   10B
....................     PIR1 &= ~0x02;          // Effacer le flag
010D:  BCF    0C.1
010E:  BCF    0A.3
010F:  BCF    0A.4
0110:  GOTO   1CA (RETURN)
.................... }
.................... 
.................... /*
....................  * Calcule la valeur de PR2 pour une fréquence donnée
....................  */
.................... unsigned int16 calculate_pr2(unsigned int16 frequency, unsigned int8 prescaler) {
....................     unsigned int32 pr2_calc;
....................     
....................     // Formule: PR2 = [Fosc / (4 * prescaler * Fpwm)] - 1
....................     pr2_calc = (16000000UL / (4UL * prescaler * frequency)) - 1;
*
0071:  CLRF   7A
0072:  MOVF   2C,W
0073:  MOVWF  79
0074:  RLF    79,W
0075:  MOVWF  31
0076:  RLF    7A,W
0077:  MOVWF  32
0078:  RLF    31,F
0079:  RLF    32,F
007A:  MOVLW  FC
007B:  ANDWF  31,F
007C:  MOVF   32,W
007D:  MOVWF  34
007E:  MOVF   31,W
007F:  MOVWF  33
0080:  MOVF   2B,W
0081:  MOVWF  36
0082:  MOVF   2A,W
0083:  MOVWF  35
*
0098:  MOVF   79,W
0099:  MOVWF  7A
009A:  MOVF   78,W
009B:  MOVWF  31
009C:  MOVF   79,W
009D:  MOVWF  32
009E:  BCF    03.1
009F:  CLRF   36
00A0:  MOVLW  F4
00A1:  MOVWF  35
00A2:  MOVLW  24
00A3:  MOVWF  34
00A4:  CLRF   33
00A5:  CLRF   3A
00A6:  CLRF   39
00A7:  MOVF   79,W
00A8:  MOVWF  38
00A9:  MOVF   78,W
00AA:  MOVWF  37
00AB:  CALL   004
00AC:  MOVLW  01
00AD:  SUBWF  77,W
00AE:  MOVWF  2D
00AF:  MOVF   78,W
00B0:  MOVWF  2E
00B1:  MOVLW  00
00B2:  BTFSS  03.0
00B3:  MOVLW  01
00B4:  SUBWF  2E,F
00B5:  MOVF   79,W
00B6:  MOVWF  2F
00B7:  MOVLW  00
00B8:  BTFSS  03.0
00B9:  MOVLW  01
00BA:  SUBWF  2F,F
00BB:  MOVF   7A,W
00BC:  MOVWF  30
00BD:  MOVLW  00
00BE:  BTFSS  03.0
00BF:  MOVLW  01
00C0:  SUBWF  30,F
....................     
....................     // Limiter à 255 (maximum pour un registre 8 bits)
....................     if(pr2_calc > 255) {
00C1:  MOVF   30,F
00C2:  BTFSS  03.2
00C3:  GOTO   0CB
00C4:  MOVF   2F,F
00C5:  BTFSS  03.2
00C6:  GOTO   0CB
00C7:  MOVF   2E,W
00C8:  SUBLW  00
00C9:  BTFSC  03.0
00CA:  GOTO   0D0
....................         pr2_calc = 255;
00CB:  CLRF   30
00CC:  CLRF   2F
00CD:  CLRF   2E
00CE:  MOVLW  FF
00CF:  MOVWF  2D
....................     }
....................     
....................     // Vérifier la valeur minimale
....................     if(pr2_calc < 1) {
00D0:  MOVF   2D,F
00D1:  BTFSS  03.2
00D2:  GOTO   0E1
00D3:  MOVF   2E,F
00D4:  BTFSS  03.2
00D5:  GOTO   0E1
00D6:  MOVF   2F,F
00D7:  BTFSS  03.2
00D8:  GOTO   0E1
00D9:  MOVF   30,F
00DA:  BTFSS  03.2
00DB:  GOTO   0E1
....................         pr2_calc = 1;
00DC:  CLRF   30
00DD:  CLRF   2F
00DE:  CLRF   2E
00DF:  MOVLW  01
00E0:  MOVWF  2D
....................     }
....................     
....................     return (unsigned int16)pr2_calc;
00E1:  MOVF   2D,W
00E2:  MOVWF  78
00E3:  MOVF   2E,W
00E4:  MOVWF  79
.................... }
.................... 
.................... /*
....................  * Définit le duty cycle avec une valeur brute (0-1023)
....................  */
.................... void pwm_set_duty_(unsigned int16 duty_value) {
....................     unsigned int8 dc1b;
....................     
....................     // Limiter la valeur au maximum permis
....................     if(duty_value > max_duty_value) {
*
0172:  MOVF   21,W
0173:  SUBWF  28,W
0174:  BTFSS  03.0
0175:  GOTO   180
0176:  BTFSS  03.2
0177:  GOTO   17C
0178:  MOVF   27,W
0179:  SUBWF  20,W
017A:  BTFSC  03.0
017B:  GOTO   180
....................         duty_value = max_duty_value;
017C:  MOVF   21,W
017D:  MOVWF  28
017E:  MOVF   20,W
017F:  MOVWF  27
....................     }
....................     
....................     // Limiter à 1023 (10 bits max)
....................     if(duty_value > 1023) {
0180:  MOVF   28,W
0181:  SUBLW  03
0182:  BTFSC  03.0
0183:  GOTO   188
....................         duty_value = 1023;
0184:  MOVLW  03
0185:  MOVWF  28
0186:  MOVLW  FF
0187:  MOVWF  27
....................     }
....................     
....................     // Écrire les 8 bits MSB dans CCPR1L
....................     CCPR1L = (duty_value >> 2) & 0xFF;
0188:  RRF    28,W
0189:  MOVWF  2B
018A:  RRF    27,W
018B:  MOVWF  2A
018C:  RRF    2B,F
018D:  RRF    2A,F
018E:  MOVLW  3F
018F:  ANDWF  2B,F
0190:  MOVF   2A,W
0191:  MOVWF  15
....................     
....................     // Écrire les 2 bits LSB dans CCP1CON<5:4>
....................     dc1b = duty_value & 0x03;
0192:  MOVF   27,W
0193:  ANDLW  03
0194:  MOVWF  29
....................     
....................     // Mettre à jour CCP1CON
....................     CCP1CON = 0x0C | (dc1b << 4);
0195:  SWAPF  29,W
0196:  MOVWF  77
0197:  MOVLW  F0
0198:  ANDWF  77,F
0199:  MOVF   77,W
019A:  IORLW  0C
019B:  MOVWF  17
.................... }
.................... 
.................... /*
....................  * Définit le duty cycle en pourcentage (0-100%)
....................  */
.................... void pwm_set_duty_percent(unsigned int8 percent) {
....................     unsigned int16 duty_val;
....................     
....................     // Limiter le pourcentage
....................     if(percent > 100) {
*
0111:  MOVF   24,W
0112:  SUBLW  64
0113:  BTFSC  03.0
0114:  GOTO   117
....................         percent = 100;
0115:  MOVLW  64
0116:  MOVWF  24
....................     }
....................     
....................     // Convertir pourcentage en valeur
....................     duty_val = ((unsigned int32)percent * max_duty_value) / 100;
0117:  CLRF   2A
0118:  CLRF   29
0119:  CLRF   28
011A:  MOVF   24,W
011B:  MOVWF  27
011C:  MOVF   2A,W
011D:  MOVWF  2E
011E:  MOVF   29,W
011F:  MOVWF  2D
0120:  MOVF   28,W
0121:  MOVWF  2C
0122:  MOVF   27,W
0123:  MOVWF  2B
0124:  CLRF   32
0125:  CLRF   31
0126:  MOVF   21,W
0127:  MOVWF  30
0128:  MOVF   20,W
0129:  MOVWF  2F
*
0153:  MOVF   7A,W
0154:  MOVWF  2A
0155:  MOVF   79,W
0156:  MOVWF  29
0157:  MOVF   78,W
0158:  MOVWF  28
0159:  MOVF   77,W
015A:  MOVWF  27
015B:  BCF    03.1
015C:  MOVF   7A,W
015D:  MOVWF  36
015E:  MOVF   79,W
015F:  MOVWF  35
0160:  MOVF   78,W
0161:  MOVWF  34
0162:  MOVF   77,W
0163:  MOVWF  33
0164:  CLRF   3A
0165:  CLRF   39
0166:  CLRF   38
0167:  MOVLW  64
0168:  MOVWF  37
0169:  CALL   004
016A:  MOVF   78,W
016B:  MOVWF  26
016C:  MOVF   77,W
016D:  MOVWF  25
....................     
....................     // Appliquer la valeur
....................     pwm_set_duty_(duty_val);
016E:  MOVF   26,W
016F:  MOVWF  28
0170:  MOVF   25,W
0171:  MOVWF  27
*
019C:  RETURN
.................... }
.................... 

Configuration Fuses:
   Word  1: 3F7A   HS NOWDT NOPUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
